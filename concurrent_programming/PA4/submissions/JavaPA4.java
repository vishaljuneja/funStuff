
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.SelectableChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.logging.Level;
import java.util.logging.Logger;

//to avoid hardcoding
class ConstSettings {

    public static final int CAPACITY = 5;
    public static final int THREAD_COUNT = 10;
    public static final int BUFFER_SIZE = 2000;
}

//Message object used in synchronized queue
class ClientData {

    public SocketChannel socket;
    public String message;

    public ClientData(SocketChannel socket, String message) {
        this.socket = socket;
        this.message = message;
    }
}

//Represents queue in which events generated by handleInput from reactor
// are enqueued for handling by worker threads
class HalfSyncPool {

    private BlockingQueue<ClientData> requestQueue = new ArrayBlockingQueue<>(ConstSettings.CAPACITY);

    public void put(ClientData data) throws InterruptedException {
        requestQueue.put(data);
    }

    public synchronized ClientData get() throws InterruptedException {
        return requestQueue.take();
    }
}

//interface for reactor service handler, besides standard handleInput method
// there is also getChannel method useful because Java reactor is tighly connected
// with SelectableChannel
interface ServiceHandler {

    public void handleInput(SelectionKey event);

    public SelectableChannel getChannel();
}

// Class responsible for reading data in reactor loop and generate Tasks to handle
// in Half-Sync Half-Async part
class EchoServiceHandler implements ServiceHandler {

    //Java Wrapper Facade over connected socket
    private SocketChannel connectionChannel;
    private ByteBuffer readBuffer = ByteBuffer.allocate(ConstSettings.BUFFER_SIZE);
    private String partialData = "";
    private HalfSyncPool taskQueue;

    EchoServiceHandler(SocketChannel connectionChannel, HalfSyncPool taskQueue) throws IOException {
        this.connectionChannel = connectionChannel;
        connectionChannel.configureBlocking(false);
        this.taskQueue = taskQueue;
    }

    @Override
    public void handleInput(SelectionKey event) {
        if (event.channel().equals(connectionChannel)) {
            try {
                ByteArrayOutputStream clientData = new ByteArrayOutputStream();
                int read;
                do {
                    read = connectionChannel.read(readBuffer);
                    if (read > 0) {
                        clientData.write(readBuffer.array(), 0, read);
                        readBuffer.clear();
                    }
                } while (read == ConstSettings.BUFFER_SIZE);

                String readString = partialData
                        + clientData.toString().replace("\r\n", "\n").replace("\r", "\n");
                while (readString.contains("\n")) {
                    int index = readString.indexOf("\n");
                    taskQueue.put(new ClientData(connectionChannel, readString.substring(0, index)));
                    System.out.println("Read data: " + readString.substring(0, index));
                    readString = readString.substring(index + 1);
                }
                partialData = readString;


            } catch (IOException | InterruptedException ex) {
            }
        }
    }

    @Override
    public SelectableChannel getChannel() {
        return connectionChannel;
    }
}

// Standard acceptor interface
interface Acceptor {

    public void open(int port) throws IOException;
}

// concrete acceptor implementation, maybe passed objects coould be replaced
// by Singleton by I really hate that pattern
class EchoAcceptor implements Acceptor, ServiceHandler {
    //Java Wrapper Facade over server socket
    private ServerSocketChannel serverWrapper;
    
    private Reactor reactor;
    private EchoTasks threadPool;
    private HalfSyncPool taskQueue;

    EchoAcceptor(Reactor reactor, EchoTasks threadPool, HalfSyncPool taskQueue) throws IOException {
        serverWrapper = ServerSocketChannel.open();
        serverWrapper.configureBlocking(false);
        this.threadPool = threadPool;
        this.reactor = reactor;
        this.taskQueue = taskQueue;
    }

    @Override
    public void open(int port) throws IOException {
        SocketAddress serverAddress = new InetSocketAddress(port);
        serverWrapper.bind(serverAddress);
        threadPool.activate(taskQueue);
    }

    @Override
    public void handleInput(SelectionKey event) {
        if (event.channel().equals(serverWrapper)) {
            try {
                if (event.isAcceptable()) {
                    SocketChannel connectionChannel = serverWrapper.accept();
                    if(connectionChannel != null)
                    {
                        EchoServiceHandler handler = new EchoServiceHandler(connectionChannel, taskQueue);
                        reactor.registerHandler(handler);
                    }
                }
            } catch (IOException ex) {
                Logger.getLogger(EchoAcceptor.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }

    @Override
    public SelectableChannel getChannel() {
        return serverWrapper;
    }
}

// Part of Half-Sync part, each event in queue is processed by one thread
class ThreadWorker implements Runnable {

    HalfSyncPool taskPool;

    
    public ThreadWorker(HalfSyncPool taskPool ) {
        this.taskPool = taskPool;
    }

    @Override
    public void run() {
        if (taskPool == null) {
            throw new RuntimeException("Thraed worker must have acces to task pool");
        }
        String message = "Thread: " + String.valueOf(Thread.currentThread().getId()) + " is attending request" + System.lineSeparator();
        while (true) {
            try {
                ClientData data = taskPool.get();
                ByteBuffer buffer = ByteBuffer.wrap((message + data.message).getBytes());
                data.socket.write(buffer);

            } catch (InterruptedException | IOException ex) {
            }
        }
    }
}

// Class responsible for spawning pool of threads as requested in assignment
class EchoTasks {

    public ExecutorService threadPool = Executors.newFixedThreadPool(ConstSettings.THREAD_COUNT);

    public void activate(HalfSyncPool taskPool) {
        for (int i = 0; i < ConstSettings.THREAD_COUNT; i++) {
            threadPool.submit(new ThreadWorker(taskPool));
        }
    }
}

// main reactor interface, I omitted removeHandler because Assignement says we should not
// bother about cleaning
interface Reactor {

    public void registerHandler(ServiceHandler handler) throws ClosedChannelException;

    public void reactorLoop() throws IOException;
}

//Concrete implementation of Reactor, using Selector for event demultiplexing
class EchoReactor implements Reactor {

    private Selector eventSelector;

    public EchoReactor() throws IOException {
        eventSelector = Selector.open();
    }

    @Override
    public void registerHandler(ServiceHandler handler) throws ClosedChannelException {
        SelectableChannel channel = handler.getChannel();
        channel.register(eventSelector, channel.validOps(), handler);
    }

    @Override
    public void reactorLoop() throws IOException {
        while (eventSelector.isOpen()) {

            eventSelector.select();
            for (SelectionKey event : eventSelector.selectedKeys()) {
                ServiceHandler handler = (ServiceHandler)event.attachment();
                handler.handleInput(event);
            }
        }
    }
}

public class JavaPA4 {

    /**
     * Main method - implemented as Assignment told to - However personally 
     * I would implement flow slighly different - with better ownership for Objects
     * One in assignemnet is suited for hatred Singleton...
     * 
     * @param args optional - port used by server
     */
    public static void main(String[] args) throws IOException {
        int port = 13300;
        if (args.length > 0) {
            try {
                port = Integer.parseInt(args[0]);
            } catch (NumberFormatException ex) {
                //do nothing
            }
        }
        HalfSyncPool syncPool = new HalfSyncPool();
        EchoTasks taskPool = new EchoTasks();
        Reactor reactor = new EchoReactor();
        EchoAcceptor acceptor = new EchoAcceptor(reactor, taskPool, syncPool);
        
        reactor.registerHandler(acceptor);
        acceptor.open(port);
        reactor.reactorLoop();
    }
}
